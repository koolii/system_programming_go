# 低レベルアクセスへの入り口1(io.Writer)

少ない記述量で、比較的高速なのは、抽象化レイヤーを扱いやすい構造にしているから

* `io.Writer` - 出力の抽象化
* `io.Reader` - 入力の抽象化
* `channel` - 通知の抽象化

この章では `io.Writer` を行なう

## `io.Writer`はOSが持つファイルのシステムコールの相似形

OSへのシステムコールをファイルディスクリプタ(FD)に対して行なう(実際、 fmt.Printlnの内部で使っている `syscall.Write` の `f.fd` が相当する)
FDを使うことで本来ファイルじゃないものをファイルと同等に使用することが出来る => `ファイルディスクリプタ(FD)で抽象化`

FDはOSレイヤーで用意されているプロセスを抽象化する仕組みで、プロセスが起動されるとOSは3つの疑似ファイルを作成される
(ファイルをオープンしたり、ソケットをオープンするたびに1つずつ大きい値になるらしい)

* 0: 標準入力
* 1: 標準出力
* 2: 標準エラー出力

この仕様はWindowsだと違うので、Golang側が夫々のOSの差分を吸収している => `io.Writer` はその一例でインターフェースと言う仕組みで実装されている

## `io.Writer`はインタフェース

fmt.Printlnの内部で呼ばれていた`syscall.Write() - os/file.go` は「osパッケージのFile型に定義されている `Write` と言うメソッド」とわかる

```go
func (f *File) Write(b []byte) (n int, err error) {}
```

* `(f *File)` の部分は、この定義がFile型の構造体へのポインタfに対するメソッドであることを示す

## 実際に利用している例

* ファイル出力 => `src/02/output.go`
* 画面出力(fmt.Println) => `src/02/println.go`
* バッファ => `src/02/buffer.go`
* インターネットアクセスの送信 => `src/02/http.go`
* io.Writerのデコレータ => `src/02/decorator.go`
* フォーマットしてデータをio.Writerに書き込む => `src/02/format.go`

## インタフェースの実装状況／利用状況を調べる
※ インタフェースの変数にポインタを代入したり、メソッドの引数にポインタを渡したりする時に自動でチェックされる
Goでは明示的にインタフェースを満たしているかどうかを記載しないためコードを追うだけだと大変なので `godoc` と言うツールを使う

Webサーバとして起動し、ブラウザでgolang.orgのパッケージのドキュメントを見るのが典型的な使い方で `-analysis type` をつけるとインタフェース分析をしてくれる

依存パッケージが多いと処理が大変なので、一時的にGOPATHを変更するのもあり

`godoc -http ":6060" -analysis type`
`GOPATH=/ godoc -http ":6060" -analysis type`

## 低レベルの機能を組み合わせて入出力APIを作る
GolangにはIO処理がスクリプト並に簡単に出来る（下記参照）
だが、結局は `io.Writer` や `io.Reader` を隠蔽して特定の条件下で動作するようにしていて
これらの2つを使って同じように実装してみる

* `ioutil.WriteFile()` => これだけでファイル書き込みができる
* `ioutil.ReadFile()` => これだけでファイル読み込みできる
* `http.Get()` => これだけでHTTPのGETリクエストを送信できる
* `htttp.Post()` => これだけでHTTPのPOSTリクエストを送信できる