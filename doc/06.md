# 6章TCPソケットとHTTPの実装

ソケット通信と有効なAPIを使って、HTTPの機能を再現していく

### rpc(Remote Procedure Calling)
サーバが用意している様々な機能をローカル上にある関数のように簡単に呼び出そうと言う仕組み
Go言語ではJSON-RPCが標準ライブラリとして提供されている

### REST
RESTの思想のシステムがRESTfulと言う
RESTfulの究極形態（第四携帯）として位置づけられているのがHATEOASという考え方

### GraphQL
RESTfulとは違う路線で、RPCベースのGraphQLにも注目が集まっている
FBが提唱しているアプリケーション層のプロトコルでGithubが利用している

個人的な理解だと夫々のほしい項目を個別に取得するやり方で、制約なども付けることが出来る

## ソケットとは
アプリケーション層からトランスポート層のプロトコルを利用する時のAPIとしてソケットという仕組みを利用
TLS(SSL)はソケットとHTTPの間に入って暗号化を行う

他のアプリとやり取りをする時の通信をIPCといい、ソケット(TCP/UDP/Unixドメインソケット)もその1つ

## ソケット通信の基本構造

サーバ：Listen()関数を使い、ソケットを開いて待ち受ける
クライアント：Dial()関数を使い、開いているソケットに接続し、通信を行う

現実的で最低限なTCPサーバ => `src/06/mini-tcp-server.go`

## Go言語でHTTPサーバを実装する

※普通は`net/http`のパッケージを使うが今回はnetパッケージをそのまま使ってHTTPサーバを書いてみる
  => `src/06/http-server.go`
一緒にクライアント側のファイルも作成
  => `src/06/http-client.go`

## 速度改善 HTTP/1.1のKeep-Alive
サーバとクライアントの周りは通信のボトルネックになりやすくパフォーマンスに問題が出やすい
HTTP/1.0だとTCPコネクションを一回完了する毎に接続を切っていたが、Keep-Aliveを使うことで
TCP接続のコネクションを維持して使いまわす

TCPでコネクションを確立・切断をするのに1.5RTT(ラウンドトリップタイム)
RTTは物理的な距離等でも変化するから1RTTあたりの時間は変わるが、どちらにせよRTTは少ないほうが速度はよい

なので、Keep-Aliveを使うことで往復3RTT分のオーバーヘッドを減らせる、Keep-Aliveに対応させたHTTPサーバを既に作ったHTTPサーバに組み込む
  => `src/06/http-server.go`
  => `src/06/http-client.go`

## 速度改善 圧縮
圧縮してもパケット伝達の速度は変わらないが、転送を開始してから終了するまでの時間は短縮される
一般的にはgzip圧縮が使われているので、ここでgzip圧縮を実装する
  => `src/06/http-server.go`
  => `src/06/http-client.go`

## 速度改善 チャンク形式のボディー送信
巨大なファイルをクライアントに返す時に全体がメモリにロードされるからリソースが枯渇してしまう
そこでチャンク形式を使って回避することが出来る
チャンク形式は準備が整った部分からレスポンスを開始出来るので、レスポンスの初動も早くなる
送信終了は送信されたパケットのサイズが0の場合に終了と判断される

また、サイズが1つのレスポンスに定まらないのでヘッダにサイズを入れる必要もなくなる
  => `src/06/chunk-server.go`