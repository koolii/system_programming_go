# Go言語について

* Go言語はデータ自体が型情報を持っている

## インターフェース
* Javaのインターフェースと基本同じと考えて良い
* Goだとインターフェース名に `~er, ~or` とつけることが多いらしい
* メンバを宣言できない(そのために構造体を利用する)
* 構造体も他の言語同じようなもの(メンバもメソッドも持てる)
* `func` 予約語とメソッド名の間にレシーバーを置くと、構造体にメソッドを定義したことになる => `interface.go#L16`
* 構造体にインターフェースを実装する時に `implements` 等のキーワードは必要ない
  * 勝手にGoコンパイラが判定してくれて、互換性チェックを実際に行っている箇所は `interface.go#24,25`)
* 副作用のあるメソッドではレシーバーの型をポインタ型にする(ここでは `(g *Greeter)`)
  * ポインタ型といっても、アクセス方法は変わらないし、C言語よりも扱いやすい

=> `go run docs/src/interface.go`

## 配列に要素を追加する
GO言語で配列(厳密にはスライス)に要素を追加するには、`append`を使い、オブジェクト指向のようにメソッドを持ったオブジェクトではない

```go
// 配列 = append(配列, 要素)
array = append(array, element)
```

## goroutine
OSのネイティブなスレッドを扱いやすくしている並列処理機構
`go`というキーワードを付けて実行すればgoroutineが作られて並列実行される

```go
// 既存の関数呼び出し
Function()
// 無名関数を定義、即実行
func() {
  fmt.Println("immediately")
}()

// 別のgoroutineを作って、既存の関数を呼び出し(`src/04/goroutine-func.go`)
go Function()
// 別のgoroutineを作って、無名関数を作成、即実行(`src/04/goroutine-closure.go`)
go func() {
  fmt.Println("goroutine immediately")
}()
```

### チャネル
Go言語のチャネルは、キューと並列処理用の「並列でアクセスされても正しく処理される」ことを保証する機能を組み合わせたもの

#### チャネルは、データを順序よく受け渡すためのデータ構造である
キューとしてのチャネルは、データを貯める配列
チャネルには、普通の配列とはやや異なり、ランダムアクセスできない

#### チャネルは、並列処理されても正しくデータを受け渡す同期機構である
チャネルは整合性が損なわれることがない、安全なデータ構造
同時に複数のgoroutineでチャネルに読み書きを行っても、1つのgoroutineだけがデータを投入できる（同時にデータの取り出しも1つのgoroutineだけ）
Go言語では、goroutine間の情報共有方法としてチャネルを使うことが推奨されている

#### チャネルは、読み込み／書き込みで準備ができるまでブロックする機能である
チャネルはデータがない状態で読み込みをしようとすると、他のgoroutineがそのチャネルにデータを投入して読み込の準備ができるまでブロックして待ちます
他にもバッファに空きがない状態で書き込みをしようとすると、他のgroutineがデータを取り出して空きが出るまでブロックする

Go言語のアプリケーションを書く時のチャネルの使用例
* データ入力元、データ出力先、終了状態の伝達等
* 終了とタイムアウトの管理にコンテキスト(context.Context)という仕組みを利用しているが、そのコンテキストの終了判定(Done())もチャネルを介して行う
* イベントの通知として、並列処理で処理が終了したことの通知でよく使われる(`src/04/channel-notify.go`)

#### チャネルの使用方法

```go
// バッファなし
// 受け取り側が受信をしないと送信側もブロックされる
tasks := make(chan string)
// バッファあり
// バッファがあるのでその限りまではすぐに処理を完了し、次のタスクに移る
tasks := make(chan string, 10)

// 読み込みは基本的に送信側が送信するまでブロックする、ブロックを避けるには`select`を使う方法も有効
// チャネルを閉じるには`close(channel)`を使う、閉じたあとで、読み込み側ではデフォルト値の`0`が返り(文字列は空文字列)、送信しようとするとパニック

// send data
tasks <- "cmake .."
tasks <- "cmake . --build Debug"

// receive data
task := <-tasks
// receive data && channel closed or not
// チャネルがまだオープンであればokにtrueが返る
task, ok := <-tasks
// データを読み捨てる場合は代入文も不要
// 終了待ちのチャネルでデータそのものに意味がない場合に使ったりする
<-wait
```

チャネルがクローズされているかどうか受信側に確実に知らせるための明確な方法が無いのは注意しなければならない
正常値として0を返す場合は、デフォルト値の0と正常値の0なのか判別ができない

プログラムの糸を明確にするには、終了情報のやり取りのために別のチャネルを利用すべき
チャネルは、クローズしなくてもガベージコレクタに回収される
データを流すチャネルは、正常なデータに本来入れてないデータa（ゼロや空文字）が紛れ込んでしまう可能性があるため、クローズしないほうがいい
逆に、終了情報のシグナルを目的としたチャネルは複数のgoroutineが監視している場合でも全てに終了を通知できるので、close()したほうが良い

**チャネルは作成時のバッファサイズの有無でチャネルの状態が挙動が一部変わっているので、P66はよく確認するようにした方が良い**


### for
チャネルは、Go言語のコア機能、for文との組み合わせ(`src/04/channel-loop.go`)

### チャネルとselect文
ブロックする複数のチャネルを同時に並列で待ち受け、データが到着したチャネルから順に取り出して処理する、
あるいはブロックする複数のチャネルの書き込みが完了するのを並列で待ち受け、データが先に送信できたチャネルにのみデータを投入するのにselect文を使う
(説明が難しい。Promise.all/Promise.raceみたいなのかな？)

select文は一度ハンドリングすると終わってしまうから、forループ内で動作させることが多い
case文は適当なチャネルの読み込みコードを列挙し、それぞれのハンドラを記述する

```go
// Go言語のselect文の基本的な使用方法
// このプログラムだと、どれかのチャンネルが応答するまでブロックし続ける(ただし、defaultを有効にするとブロックせずにすぐに終了)
// **defaultを使っていると、チャネルにデータが入るまでポーリングでループを回したい場合に使える**
for {
  select {
  case data := <-reader:
    // 読み込んだデータを利用
    fmt.Println(data)
  case <-exit:
    // ループを抜ける
    break
  // default:
  //   // まだデータは来ていない
  //   break
  }
}
```

### コンテキスト(`src/04/context.go`)
深いネスト内、あるいは派生ジョブなどがあって複雑なロジックの中でも正しく終了やキャンセル、タイムアウトが実装できるようにする仕組みのこと

### システムからの通知
時間がかかるものや、いつ返ってくるか分からないものがいくつかある

* サーバのプロセスに、クライアントからつなげてくるのを待つ
* 巨大なファイルを読み込んで、完了まで待機 etc..

対応策
* OSが何かを準備する時に、それを待っているプロセスがどれかを把握し、準備がおわるまではプロセスを止め、準備ができたらプロセスに処理を戻す(ファイル・ソケットのブロッキング入力)
* OSが何かを準備する時に、終わっていなくても即座に処理を返す。一部でも完了していなかったら、その一部のデータとまだ続きがあることを返す(ノンブロッキング入力)
* プロセスが実行中なら一時停止、予め設定したコールバック関数を呼び出す(シグナル)

### OSからのシグナルをチャネルで受け取る(`src/04/signal.go`)
シグナルはプロセス間通信の手段

### サーバとクライアントの接続

#### TCP
net.Listen()関数を呼び、帰ってきたnet.Listenerインタフェースでクライアントが接続してくるのを待つ
クライアントが接続したら、net.ListenerインタフェースのAccept()メソッドを呼び、お互いにデータを送受信するためのnet.Connインタフェースのオブジェクトを取得する

#### UDP
net.ListenPacket()を呼ぶと、色々すっ飛ばしてデータ送受信のためのnet.PacketConnというインタフェースが返る