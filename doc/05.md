# 5章システムコール

## システムコール
特権モードでOSの機能を呼ぶこと

現在はプロセスは自分のことだけに集中し、メモリ管理や時間管理などはプロセスの外からOSが全てを行う
CPUは仕組みとして動作モードが提供されていて、OS毎に違う
  主流はOSが動作する特権モード、一般的なアプリが動作するユーザーモード
特権モードでのみ許可されている機能を **システムコール** を介して、ユーザーモードのアプリから利用できる
システムコールが使えないと、色々な制約(P77)が出るが、最終的にはプログラムを起動して、プロセス作成もできないし、終了させることもできない

## Go言語のシステムコール実装

`os.Create()`のシステムコールを確認するプログラム => `src/os-create.go`

### Mac側
runtimeパッケージのentersyscall()関数とexitsyscall()関数が呼び出される

Go言語では、システムコールのブロックなどが原因で、実行しなければならないタスクが多くあるのに動けるスレッドが不足すると
OSに依頼して新しい作業用スレッドを生成する

これはGo言語の実行モデルの効率の面でメリットがあり、Go言語特有

逆にスレッド関係の処理を行わないsyscall.RawSyscall()という関数もある

## POSIX
POSIXは、OS感で共通のシステムコールを決めることで、アプリの移植性を高めるために作られたIEEE規格
最終的にOSに仕事を依頼するのはシステムコールで、POSIXはシステムコールのインターフェースを定義している
=> OS間のポータビリティを維持したい

具体的なPOSIXの内容はC言語の関数名、引数、返り値を定義してる
POSIXのコンセプト的には、このC言語の定義をそのまま使うべきなんだが、Go言語では自力でシステムコールの番号を指定するように自力で実装して、ポータビリティを保っている
これにより、クロスコンパイル、他のOSで動くバイナリが簡単に作成できる

## システムコールのモニタリング
Go言語はmain()関数の中でも大量のシステムコールをしているのでモニタリングには少し注意が必要

### Mac
macOSはFreeBSDのtrussに似たdtrussコマンドを使う、DTraceという仕組みを使ったツール
通常のLinuxではstraceコマンドでシステムコールをモニタリング出来る

```bash
sudo dtruss ./実行ファイル
sudo dtress -p プロセスID
```

また今のmacOSセキュリティレベルが上って、自分でその制御を外す必要がある
SystemIntegrity Protection(SIP)

また、ツール経由でGo言語のプログラムを起動するとpanicが起こるらしいので、`C`というモジュールをimportする
